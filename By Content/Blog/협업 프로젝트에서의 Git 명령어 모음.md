안녕하세요😄


이번 포스팅에서는 여러 명이 참여하는 협업 프로젝트에서 제가 자주 사용했던 Git CLI 명령어를 공유합니다.

기본적으로 Git flow를 지향하며, 여러개의 브랜치(branch)를 나누어 작업하는 경우에 주로 사용하였습니다.

---

## **1\. 브랜치 나누기**

#### **1) 브랜치(Branch) 만들기**

Git flow에 따르면, master, develop, feature 등등 작업의 성격에 맞게 브랜치를 나눕니다.


`$ git branch [브랜치명]`

으로 브랜치를 만들 수 있습니다.

이럴 경우 현재 위치해 있는 브랜치에서 분기하여 새로운 브랜치가 만들어집니다.

다른 곳에서 분기하는 브랜치를 만들고 싶다면 다음 명령어를 이용해 주세요.

`$ git branch [브랜치명] [부모브랜치명]`

이럴 경우 로컬에 브랜치가 생성되며 브랜치에서 작업한 내용을 푸시할 경우 리모트에도 적용되게 됩니다.

(리모트가 무엇인지 모르시는 분들은 다음 링크를 참고해 주세요)

[https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EC%A0%80%EC%9E%A5%EC%86%8C](https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EC%A0%80%EC%9E%A5%EC%86%8C)

그리고 checkout 명령어를 통해 해당 브랜치로 이동할 수 있습니다.

`$ git checkout [브랜치명]`

생성과 이동을 동시에 하고 싶은 경우 다음 명령어를 이용하면 됩니다.

`$ git checkout -b [브랜치명]`

#### **2) merge**

새로운 기능 개발을 위해 feature/ui라는 브랜치를 만들고 이동했다고 가정해 봅시다.

로컬에 작업을 한 부분을 feature/ui에 반영합니다.

`$ git add []`  
`$ git commit -m "[커밋명]"`  
`$ git push origin feature/ui`

그리고 해당 기능에 대한 내용의 테스트를 거치고 develop 브랜치에 합치는 경우, 다음과 같이 사용합니다.

`$ git checkout develop`  
`$ git merge feature/ui`

이 때 중요한 점은, develop 브랜치에 진입하였을 때

git pull origin develop 을 이용하여 다른 사람이 업로드한 부분을 받고 합쳐야만 불필요한 충돌을 피할 수 있습니다.

#### **3) 브랜치 삭제하기**

브랜치에 작업을 완료하고 더이상 필요하지 않다고 생각이 되면, 혼선을 피하기 위해 브랜치를 바로바로 지워줍니다.

`$ git branch --delete feature/ui`

하지만 이럴 경우 내가 브랜치에 작업한 내용이 남아 있을 경우, Git에서 해당 내용이 날라가지 않도록 한번 막아줍니다.

이 작업한 내용이 날라가도 상관 없다면, 다음과 같이 강제로 날려 줍시다.

`$ git branch -D feature/ui`

이러면 이제 로컬에서 feature/ui 브랜치는 날라가게 됩니다.

하지만 깃 홈페이지에서 확인해 보면 해당 브랜치가 아직 남아있는 걸 확인하실 수 있을 겁니다.

로컬에서만 지우지 말고 리모트에도 지운 내용을 반영해 줘야 합니다.

`$ git push origin :feature/ui`

이러면 리모트에서도 깔끔하게 지워지게 됩니다.

---

## **2\. 작업 되돌리기**

때로는 로컬에서 작업한 내용을 날려버리거나, 이미 리모트에 푸시해 버린 내용을 되돌리고 싶은 경우가 있습니다.

(저는 이런 경우가 매우 많았습니다 ㅠ ㅠ)

이럴 때는 git reset이라는 명령어를 사용하게 됩니다.

#### **1) 로컬에 작업한 내용을 날리고 싶을 때**

마지막 커밋 반영 이후 로컬에 어떠한 작업을 했는데, 모종의 이유로 날려야 할 일이 생겼습니다.

이러한 경우 날려버리면 다시 복구할 방법이 없기 때문에, 강제 옵션을 통해 날려버려야 합니다.

`$ git reset --hard HEAD`

이러면 현재 로컬에 작업했던 내용이 다 날라가고 HEAD에 있던 커밋 기준으로 로컬에 반영되게 됩니다.

#### **2) 이전 커밋으로 되돌리고 싶을 때**

작업 이후에 수많은 작업을 했는데, 이게 불필요한 작업이란 것을 깨달았습니다.

눈물을 머금고 이전 커밋 상황으로 되돌려야 할 일이 발생합니다.

직접 몇 단계 커밋 전으로 되돌리는 방법이 있고, 커밋 해시값을 알아내어 되돌리는 방법이 있습니다.

우선 바로 전 커밋으로 돌리고 싶은 경우 위에서 사용하는 방법과 비슷합니다.

`$ git reset HEAD^`  
`$ git pull`

하지만 이러면 우리의 착한 Git은 충돌을 감지하고 경고 메시지를 띄웁니다.

이럴 경우 충돌을 직접 바로잡아 주거나, 그냥 강제로 땡겨버리는 방법이 있는데요.

`$ git reset --hard HEAD^`  
`$ git pull`

단, 이러면 사이 커밋 내역들까지 전부 사라져 복구할 방법이 없어지므로, 주의해야 합니다.

이때 2번째 전 커밋으로 되돌리고 싶다면 HEAD^^ , 3번째는 HEAD^^^ 이런식으로 사용 가능하지만,

많이 떨어져 있는 커밋이라면 해시값을 알아내어 되돌리는 방법이 있습니다.

`$ git log`

명령어 혹은 홈페이지의 커밋 내역에서 커밋의 해시값을 알아낼 수 있습니다.

`$ git reset --hard [해시값]`  
`$ git pull`

## **3\. 태그 달기**

프로젝트의 버전 관리를 위하여 배포 시 마다 versioning을 하는 경우가 잦습니다.

git flow에 따르면 배포를 위해 master에 머지할 때 마다 versioning을 하는 경우가 일반적이라고 볼 수 있겠네요.

이때 git tag라는 것을 사용합니다.

develop에서 작업한 내용을 master에 반영하였다고 가정해 봅시다.

`$ git checkout master`  
`$ git merge develop`  
`$ git push origin master`

이러면 develop에서 작업한 커밋 내용이 master에 적용되겠죠?

이때 커밋명에 태그를 달아 주면 모두가 알 수 있게끔 버전 관리가 가능합니다.

우선 git log를 통해 태그를 달고 싶은 시점의 커밋의 해시값을 알아냅시다.

이때 해시값의 앞 5자리만 입력해도 충분합니다. v1.0.2이라는 태그를 단다고 가정해 볼까요?

`git tag v1.0.2 [해시값]`

이러면 다음과 같이 터미널에서도 확인할 수 있습니다.

[##_Image|kage@boi2QE/btqF2RI0y2A/2YkVxOrYekm7wXzrmwr0IK/img.png|alignLeft|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|||_##]

이제 이 내용을 리모트에도 푸시하여 모두가 알 수 있게끔 합시다.

`git push origin [태그명]`

아니면 태그 여러개를 모두 한번에 푸시하고 싶다면

`git push origin --tags`

이제 모두가 태그를 확인할 수 있게 됩니다. 참 쉽쥬 ?